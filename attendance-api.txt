// server.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const dotenv = require('dotenv');
const morgan = require('morgan');
const helmet = require('helmet');
const compression = require('compression');

// Importar rutas
const eventRoutes = require('./routes/events');
const personRoutes = require('./routes/persons');
const attendanceRoutes = require('./routes/attendance');

// Configuración
dotenv.config();
const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));
app.use(helmet());
app.use(compression());

// Conexión a MongoDB
mongoose
  .connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => console.log('MongoDB conectado'))
  .catch((err) => console.error('Error al conectar a MongoDB:', err));

// Rutas
app.use('/api/events', eventRoutes);
app.use('/api/persons', personRoutes);
app.use('/api/attendance', attendanceRoutes);

// Ruta de prueba
app.get('/', (req, res) => {
  res.json({ message: 'API de Control de Asistencia' });
});

// Manejador de errores
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    error: err.message || 'Error en el servidor',
  });
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`Servidor ejecutándose en el puerto ${PORT}`);
});

// .env (crear este archivo en la raíz del proyecto)
/*
PORT=5000
MONGO_URI=mongodb://localhost:27017/attendance-app
NODE_ENV=development
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=1d
*/

// models/Event.js
const mongoose = require('mongoose');

const EventSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: [true, 'Por favor ingrese el nombre del evento'],
      trim: true,
      maxlength: [100, 'El nombre no puede exceder los 100 caracteres'],
    },
    description: {
      type: String,
      required: [true, 'Por favor ingrese una descripción'],
      trim: true,
      maxlength: [500, 'La descripción no puede exceder los 500 caracteres'],
    },
    date: {
      type: Date,
      required: [true, 'Por favor ingrese la fecha del evento'],
    },
    status: {
      type: String,
      enum: ['open', 'closed'],
      default: 'open',
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Agregar índices para mejorar el rendimiento en búsquedas
EventSchema.index({ name: 1 });
EventSchema.index({ date: 1 });
EventSchema.index({ status: 1 });

// Virtual para acceder a las personas asociadas a este evento
EventSchema.virtual('persons', {
  ref: 'Person',
  localField: '_id',
  foreignField: 'eventId',
  justOne: false,
});

// Virtual para obtener el conteo de asistentes
EventSchema.virtual('attendanceCount', {
  ref: 'Attendance',
  localField: '_id',
  foreignField: 'eventId',
  count: true,
});

module.exports = mongoose.model('Event', EventSchema);

// models/Person.js
const mongoose = require('mongoose');

const PersonSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Por favor ingrese el nombre de la persona'],
    trim: true,
    maxlength: [100, 'El nombre no puede exceder los 100 caracteres'],
  },
  credentialNumber: {
    type: String,
    required: [true, 'Por favor ingrese el número de credencial'],
    trim: true,
    unique: true,
    index: true,
  },
  dni: {
    type: String,
    required: [true, 'Por favor ingrese el DNI'],
    trim: true,
    index: true,
  },
  email: {
    type: String,
    required: [true, 'Por favor ingrese el email'],
    trim: true,
    lowercase: true,
    match: [
      /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
      'Por favor ingrese un email válido',
    ],
  },
  eventId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Event',
    required: [true, 'Debe estar asociado a un evento'],
    index: true,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

// Índices compuestos para mejorar rendimiento
PersonSchema.index({ eventId: 1, credentialNumber: 1 });
PersonSchema.index({ eventId: 1, dni: 1 });

module.exports = mongoose.model('Person', PersonSchema);

// models/Attendance.js
const mongoose = require('mongoose');

const AttendanceSchema = new mongoose.Schema({
  eventId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Event',
    required: [true, 'Debe estar asociado a un evento'],
    index: true,
  },
  personId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Person',
    required: [true, 'Debe estar asociado a una persona'],
    index: true,
  },
  timestamp: {
    type: Date,
    default: Date.now,
  },
  recordedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  deviceInfo: {
    type: Object,
    default: {},
  },
});

// Asegurar que una persona solo tenga una asistencia por evento
AttendanceSchema.index({ eventId: 1, personId: 1 }, { unique: true });

module.exports = mongoose.model('Attendance', AttendanceSchema);

// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const UserSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Por favor ingrese su nombre'],
    trim: true,
  },
  email: {
    type: String,
    required: [true, 'Por favor ingrese su email'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [
      /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
      'Por favor ingrese un email válido',
    ],
  },
  password: {
    type: String,
    required: [true, 'Por favor ingrese una contraseña'],
    minlength: [6, 'La contraseña debe tener al menos 6 caracteres'],
    select: false,
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user',
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

// Encriptar contraseña
UserSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

// Generar JWT
UserSchema.methods.getSignedJwtToken = function () {
  return jwt.sign({ id: this._id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

// Comparar contraseña ingresada con la almacenada
UserSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', UserSchema);

// controllers/eventController.js
const Event = require('../models/Event');
const Person = require('../models/Person');
const Attendance = require('../models/Attendance');
const asyncHandler = require('../middleware/asyncHandler');

// @desc    Obtener todos los eventos
// @route   GET /api/events
// @access  Public
exports.getEvents = asyncHandler(async (req, res) => {
  // Permitir filtrado, paginación y ordenamiento
  let query;
  
  // Copia de req.query
  const reqQuery = { ...req.query };
  
  // Campos a excluir
  const removeFields = ['select', 'sort', 'page', 'limit'];
  removeFields.forEach(param => delete reqQuery[param]);
  
  // Crear string de consulta
  let queryStr = JSON.stringify(reqQuery);
  queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in)\b/g, match => `$${match}`);
  
  // Crear la consulta
  query = Event.find(JSON.parse(queryStr));
  
  // Seleccionar campos específicos
  if (req.query.select) {
    const fields = req.query.select.split(',').join(' ');
    query = query.select(fields);
  }
  
  // Ordenar
  if (req.query.sort) {
    const sortBy = req.query.sort.split(',').join(' ');
    query = query.sort(sortBy);
  } else {
    query = query.sort('-date');
  }
  
  // Paginación
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;
  const total = await Event.countDocuments(JSON.parse(queryStr));
  
  query = query.skip(startIndex).limit(limit);
  
  // Ejecutar consulta
  const events = await query;
  
  // Información de paginación
  const pagination = {};
  
  if (endIndex < total) {
    pagination.next = {
      page: page + 1,
      limit
    };
  }
  
  if (startIndex > 0) {
    pagination.prev = {
      page: page - 1,
      limit
    };
  }
  
  // Agregar conteos de personas y asistencias
  const eventsWithCounts = await Promise.all(events.map(async (event) => {
    const totalPeople = await Person.countDocuments({ eventId: event._id });
    const attendanceCount = await Attendance.countDocuments({ eventId: event._id });
    
    const eventObj = event.toObject();
    eventObj.totalPeople = totalPeople;
    eventObj.attendanceCount = attendanceCount;
    
    return eventObj;
  }));
  
  res.status(200).json({
    success: true,
    count: events.length,
    pagination,
    data: eventsWithCounts
  });
});

// @desc    Obtener un solo evento
// @route   GET /api/events/:id
// @access  Public
exports.getEvent = asyncHandler(async (req, res) => {
  const event = await Event.findById(req.params.id);
  
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  const totalPeople = await Person.countDocuments({ eventId: event._id });
  const attendanceCount = await Attendance.countDocuments({ eventId: event._id });
  
  const eventObj = event.toObject();
  eventObj.totalPeople = totalPeople;
  eventObj.attendanceCount = attendanceCount;
  
  res.status(200).json({
    success: true,
    data: eventObj
  });
});

// @desc    Crear un evento
// @route   POST /api/events
// @access  Private
exports.createEvent = asyncHandler(async (req, res) => {
  const event = await Event.create(req.body);
  
  res.status(201).json({
    success: true,
    data: event
  });
});

// @desc    Actualizar un evento
// @route   PUT /api/events/:id
// @access  Private
exports.updateEvent = asyncHandler(async (req, res) => {
  let event = await Event.findById(req.params.id);
  
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  event = await Event.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  });
  
  res.status(200).json({
    success: true,
    data: event
  });
});

// @desc    Eliminar un evento
// @route   DELETE /api/events/:id
// @access  Private
exports.deleteEvent = asyncHandler(async (req, res) => {
  const event = await Event.findById(req.params.id);
  
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  // Verificar si hay personas asociadas al evento
  const personsCount = await Person.countDocuments({ eventId: req.params.id });
  if (personsCount > 0) {
    return res.status(400).json({
      success: false,
      error: 'No se puede eliminar un evento con personas asociadas'
    });
  }
  
  await event.remove();
  
  res.status(200).json({
    success: true,
    data: {}
  });
});

// controllers/personController.js
const Person = require('../models/Person');
const Event = require('../models/Event');
const Attendance = require('../models/Attendance');
const asyncHandler = require('../middleware/asyncHandler');

// @desc    Obtener todas las personas
// @route   GET /api/persons
// @access  Public
exports.getPersons = asyncHandler(async (req, res) => {
  let query;
  
  // Filtrar por evento si se especifica
  if (req.query.eventId) {
    query = Person.find({ eventId: req.query.eventId });
  } else {
    query = Person.find();
  }
  
  // Filtros adicionales
  if (req.query.name) {
    query = query.find({
      name: { $regex: req.query.name, $options: 'i' }
    });
  }
  
  if (req.query.dni) {
    query = query.find({ dni: req.query.dni });
  }
  
  if (req.query.credentialNumber) {
    query = query.find({ credentialNumber: req.query.credentialNumber });
  }
  
  // Paginación
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;
  const total = await Person.countDocuments(query);
  
  query = query.skip(startIndex).limit(limit);
  
  // Ordenamiento
  if (req.query.sort) {
    const sortBy = req.query.sort.split(',').join(' ');
    query = query.sort(sortBy);
  } else {
    query = query.sort('name');
  }
  
  // Población
  if (req.query.populate) {
    query = query.populate({
      path: 'eventId',
      select: 'name date status'
    });
  }
  
  // Ejecutar consulta
  const persons = await query;
  
  // Pagination result
  const pagination = {};
  
  if (endIndex < total) {
    pagination.next = {
      page: page + 1,
      limit
    };
  }
  
  if (startIndex > 0) {
    pagination.prev = {
      page: page - 1,
      limit
    };
  }
  
  // Agregar información de asistencia para cada persona
  const personsWithAttendance = await Promise.all(persons.map(async (person) => {
    const attendance = await Attendance.findOne({
      eventId: person.eventId,
      personId: person._id
    });
    
    const personObj = person.toObject();
    personObj.hasAttended = !!attendance;
    personObj.attendanceTime = attendance ? attendance.timestamp : null;
    
    return personObj;
  }));
  
  res.status(200).json({
    success: true,
    count: persons.length,
    pagination,
    data: personsWithAttendance
  });
});

// @desc    Obtener una persona
// @route   GET /api/persons/:id
// @access  Public
exports.getPerson = asyncHandler(async (req, res) => {
  const person = await Person.findById(req.params.id).populate({
    path: 'eventId',
    select: 'name date status'
  });
  
  if (!person) {
    return res.status(404).json({
      success: false,
      error: 'Persona no encontrada'
    });
  }
  
  const attendance = await Attendance.findOne({
    eventId: person.eventId,
    personId: person._id
  });
  
  const personObj = person.toObject();
  personObj.hasAttended = !!attendance;
  personObj.attendanceTime = attendance ? attendance.timestamp : null;
  
  res.status(200).json({
    success: true,
    data: personObj
  });
});

// @desc    Crear una persona
// @route   POST /api/persons
// @access  Private
exports.createPerson = asyncHandler(async (req, res) => {
  // Verificar que el evento exista
  const event = await Event.findById(req.body.eventId);
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  // Verificar que no exista otra persona con el mismo DNI o credencial en el evento
  const existingPerson = await Person.findOne({
    eventId: req.body.eventId,
    $or: [
      { dni: req.body.dni },
      { credentialNumber: req.body.credentialNumber }
    ]
  });
  
  if (existingPerson) {
    return res.status(400).json({
      success: false,
      error: 'Ya existe una persona con el mismo DNI o número de credencial en este evento'
    });
  }
  
  const person = await Person.create(req.body);
  
  res.status(201).json({
    success: true,
    data: person
  });
});

// @desc    Actualizar una persona
// @route   PUT /api/persons/:id
// @access  Private
exports.updatePerson = asyncHandler(async (req, res) => {
  let person = await Person.findById(req.params.id);
  
  if (!person) {
    return res.status(404).json({
      success: false,
      error: 'Persona no encontrada'
    });
  }
  
  // Si se intenta cambiar el DNI o credencial, verificar que no exista ya
  if (req.body.dni || req.body.credentialNumber) {
    const existingPerson = await Person.findOne({
      eventId: person.eventId,
      _id: { $ne: person._id },
      $or: [
        { dni: req.body.dni || person.dni },
        { credentialNumber: req.body.credentialNumber || person.credentialNumber }
      ]
    });
    
    if (existingPerson) {
      return res.status(400).json({
        success: false,
        error: 'Ya existe una persona con el mismo DNI o número de credencial en este evento'
      });
    }
  }
  
  person = await Person.findByIdAndUpdate(req.params.id, req.body, {
    new: true,
    runValidators: true
  });
  
  res.status(200).json({
    success: true,
    data: person
  });
});

// @desc    Eliminar una persona
// @route   DELETE /api/persons/:id
// @access  Private
exports.deletePerson = asyncHandler(async (req, res) => {
  const person = await Person.findById(req.params.id);
  
  if (!person) {
    return res.status(404).json({
      success: false,
      error: 'Persona no encontrada'
    });
  }
  
  // Verificar si la persona tiene registros de asistencia
  const attendance = await Attendance.findOne({ personId: req.params.id });
  if (attendance) {
    return res.status(400).json({
      success: false,
      error: 'No se puede eliminar una persona con registros de asistencia'
    });
  }
  
  await person.remove();
  
  res.status(200).json({
    success: true,
    data: {}
  });
});

// @desc    Obtener todas las personas de un evento
// @route   GET /api/events/:eventId/persons
// @access  Public
exports.getEventPersons = asyncHandler(async (req, res) => {
  const event = await Event.findById(req.params.eventId);
  
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  let query = Person.find({ eventId: req.params.eventId });
  
  // Filtros opcionales
  if (req.query.name) {
    query = query.find({
      name: { $regex: req.query.name, $options: 'i' }
    });
  }
  
  if (req.query.dni) {
    query = query.find({ dni: req.query.dni });
  }
  
  if (req.query.credentialNumber) {
    query = query.find({ credentialNumber: req.query.credentialNumber });
  }
  
  // Paginación
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 100;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;
  const total = await Person.countDocuments({ eventId: req.params.eventId });
  
  query = query.skip(startIndex).limit(limit);
  
  // Ordenamiento
  if (req.query.sort) {
    const sortBy = req.query.sort.split(',').join(' ');
    query = query.sort(sortBy);
  } else {
    query = query.sort('name');
  }
  
  // Ejecutar consulta
  const persons = await query;
  
  // Información de paginación
  const pagination = {};
  
  if (endIndex < total) {
    pagination.next = {
      page: page + 1,
      limit
    };
  }
  
  if (startIndex > 0) {
    pagination.prev = {
      page: page - 1,
      limit
    };
  }
  
  // Agregar información de asistencia para cada persona
  const personsWithAttendance = await Promise.all(persons.map(async (person) => {
    const attendance = await Attendance.findOne({
      eventId: req.params.eventId,
      personId: person._id
    });
    
    const personObj = person.toObject();
    personObj.hasAttended = !!attendance;
    personObj.attendanceTime = attendance ? attendance.timestamp : null;
    
    return personObj;
  }));
  
  res.status(200).json({
    success: true,
    count: persons.length,
    pagination,
    data: personsWithAttendance
  });
});

// controllers/attendanceController.js
const Attendance = require('../models/Attendance');
const Person = require('../models/Person');
const Event = require('../models/Event');
const asyncHandler = require('../middleware/asyncHandler');

// @desc    Registrar asistencia
// @route   POST /api/attendance
// @access  Private
exports.recordAttendance = asyncHandler(async (req, res) => {
  const { eventId, personId } = req.body;
  
  // Verificar que el evento exista
  const event = await Event.findById(eventId);
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  // Verificar que el evento esté abierto
  if (event.status !== 'open') {
    return res.status(400).json({
      success: false,
      error: 'El evento está cerrado para registros de asistencia'
    });
  }
  
  // Verificar que la persona exista y esté asociada al evento
  const person = await Person.findOne({
    _id: personId,
    eventId: eventId
  });
  
  if (!person) {
    return res.status(404).json({
      success: false,
      error: 'Persona no encontrada o no asociada a este evento'
    });
  }
  
  // Verificar si ya existe un registro de asistencia
  let attendance = await Attendance.findOne({
    eventId: eventId,
    personId: personId
  });
  
  if (attendance) {
    return res.status(400).json({
      success: false,
      error: 'La asistencia ya ha sido registrada',
      data: attendance
    });
  }
  
  // Crear el registro de asistencia
  attendance = await Attendance.create({
    eventId,
    personId,
    recordedBy: req.user ? req.user.id : null,
    deviceInfo: req.body.deviceInfo || {}
  });
  
  res.status(201).json({
    success: true,
    data: attendance
  });
});

// @desc    Obtener todos los registros de asistencia
// @route   GET /api/attendance
// @access  Private
exports.getAttendances = asyncHandler(async (req, res) => {
  let query;
  
  // Copia de req.query
  const reqQuery = { ...req.query };
  
  // Campos a excluir
  const removeFields = ['select', 'sort', 'page', 'limit'];
  removeFields.forEach(param => delete reqQuery[param]);
  
  // Crear string de consulta
  let queryStr = JSON.stringify(reqQuery);
  queryStr = queryStr.replace(/\b(gt|gte|lt|lte|in)\b/g, match => `$${match}`);
  
  // Crear la consulta
  query = Attendance.find(JSON.parse(queryStr))
    .populate({
      path: 'eventId',
      select: 'name date status'
    })
    .populate({
      path: 'personId',
      select: 'name credentialNumber dni'
    });
  
  // Seleccionar campos específicos
  if (req.query.select) {
    const fields = req.query.select.split(',').join(' ');
    query = query.select(fields);
  }
  
  // Ordenar
  if (req.query.sort) {
    const sortBy = req.query.sort.split(',').join(' ');
    query = query.sort(sortBy);
  } else {
    query = query.sort('-timestamp');
  }
  
  // Paginación
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;
  const total = await Attendance.countDocuments(JSON.parse(queryStr));
  
  query = query.skip(startIndex).limit(limit);
  
  // Ejecutar consulta
  const attendances = await query;
  
  // Información de paginación
  const pagination = {};
  
  if (endIndex < total) {
    pagination.next = {
      page: page + 1,
      limit
    };
  }
  
  if (startIndex > 0) {
    pagination.prev = {
      page: page - 1,
      limit
    };
  }
  
  res.status(200).json({
    success: true,
    count: attendances.length,
    pagination,
    data: attendances
  });
});

// @desc    Obtener asistencia por evento
// @route   GET /api/events/:eventId/attendance
// @access  Private
exports.getEventAttendance = asyncHandler(async (req, res) => {
  const event = await Event.findById(req.params.eventId);
  
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  const attendances = await Attendance.find({ eventId: req.params.eventId })
    .populate({
      path: 'personId',
      select: 'name credentialNumber dni email'
    })
    .sort('-timestamp');
  
  res.status(200).json({
    success: true,
    count: attendances.length,
    data: attendances
  });
});

// @desc    Verificar asistencia de una persona
// @route   GET /api/events/:eventId/persons/:personId/attendance
// @access  Public
exports.checkAttendance = asyncHandler(async (req, res) => {
  const { eventId, personId } = req.params;
  
  // Verificar que el evento y la persona existan
  const event = await Event.findById(eventId);
  if (!event) {
    return res.status(404).json({
      success: false,
      error: 'Evento no encontrado'
    });
  }
  
  const person = await Person.findOne({
    _id: personId,
    eventId: eventId
  });
  
  if (!person) {
    return res.status(404).json({
      success: false,
      error: 'Persona no encontrada o no asociada a este evento'
    